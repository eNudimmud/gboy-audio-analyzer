<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>G*BOY Audio Analyzer v3.0 [NEUKO-AI]</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&family=Press+Start+2P&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --crt-green: #00ff00;
            --crt-amber: #ffb000;
            --crt-dark: #001100;
            --crt-glow: #00ff0044;
        }
        
        body {
            font-family: 'VT323', monospace;
            background: #000;
            color: var(--crt-green);
            line-height: 1.4;
        }
        
        .crt-container {
            background: var(--crt-dark);
            min-height: 100vh;
            padding: 20px;
            position: relative;
        }
        
        /* Scanlines */
        .crt-container::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0, 255, 0, 0.05) 2px, rgba(0, 255, 0, 0.05) 4px);
            pointer-events: none;
            z-index: 999;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            font-family: 'Press Start 2P', monospace;
            font-size: 24px;
            color: var(--crt-green);
            text-shadow: 0 0 10px var(--crt-glow);
        }
        
        .header .subtitle {
            font-size: 18px;
            color: var(--crt-amber);
            margin-top: 10px;
        }
        
        .terminal-box {
            border: 3px solid var(--crt-green);
            padding: 20px;
            margin: 20px auto;
            max-width: 1200px;
            background: rgba(0, 17, 0, 0.8);
            box-shadow: 0 0 20px var(--crt-glow);
        }
        
        .section-title {
            font-family: 'Press Start 2P', monospace;
            font-size: 14px;
            margin-bottom: 15px;
            color: var(--crt-amber);
            border-bottom: 2px solid var(--crt-green);
            padding-bottom: 10px;
        }
        
        .file-input-area {
            margin: 20px 0;
            padding: 30px;
            border: 2px dashed var(--crt-green);
            text-align: center;
            cursor: pointer;
            background: rgba(0, 255, 0, 0.05);
        }
        
        .file-input-area:hover {
            background: rgba(0, 255, 0, 0.1);
        }
        
        input[type="file"] {
            display: none;
        }
        
        .btn {
            font-family: 'VT323', monospace;
            font-size: 20px;
            padding: 10px 20px;
            background: transparent;
            color: var(--crt-green);
            border: 2px solid var(--crt-green);
            cursor: pointer;
            margin: 5px;
            transition: all 0.3s;
        }
        
        .btn:hover {
            background: var(--crt-green);
            color: var(--crt-dark);
        }
        
        .btn.active {
            background: var(--crt-green);
            color: var(--crt-dark);
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 20px 0;
            align-items: center;
        }
        
        canvas {
            width: 100%;
            border: 2px solid var(--crt-green);
            background: #000;
            margin: 10px 0;
            display: block;
        }
        
        audio, video {
            width: 100%;
            margin: 10px 0;
            border: 2px solid var(--crt-green);
            background: #000;
        }
        
        .log {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid var(--crt-green);
            padding: 15px;
            margin: 10px 0;
            font-size: 16px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .log div {
            margin: 3px 0;
        }
        
        .success { color: #00ff00; }
        .warning { color: #ffb000; }
        .error { color: #ff0000; }
        
        .hidden { display: none; }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }
        
        .stat-box {
            border: 2px solid var(--crt-green);
            padding: 10px;
            background: rgba(0, 0, 0, 0.6);
        }
        
        .stat-label {
            color: var(--crt-amber);
            font-size: 14px;
        }
        
        .stat-value {
            color: var(--crt-green);
            font-size: 18px;
            font-family: 'Press Start 2P', monospace;
        }
    </style>
</head>
<body>
    <div class="crt-container">
        <div class="header">
            <h1>G*BOY AUDIO ANALYZER</h1>
            <div class="subtitle">NEUKO-AI | v3.0 OPTIMIZED</div>
        </div>

        <!-- FILE UPLOAD -->
        <div class="terminal-box">
            <div class="section-title">&gt; UPLOAD</div>
            <div class="file-input-area" id="dropZone">
                <div style="font-size: 24px;">DROP AUDIO/VIDEO HERE</div>
                <div style="font-size: 18px; color: var(--crt-amber); margin-top: 10px;">
                    MP3, WAV, OGG, MP4, WEBM
                </div>
                <input type="file" id="fileInput" accept="audio/*,video/*">
                <button class="btn" onclick="document.getElementById('fileInput').click()">SELECT FILE</button>
            </div>
            <div id="fileLog" class="log hidden"></div>
        </div>

        <!-- MEDIA PLAYER -->
        <div id="playerSection" class="terminal-box hidden">
            <div class="section-title">&gt; PLAYER</div>
            <audio id="audioElement" controls></audio>
            <video id="videoElement" controls class="hidden"></video>
            <div class="stats">
                <div class="stat-box">
                    <div class="stat-label">DURATION</div>
                    <div class="stat-value" id="duration">--</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">SAMPLE RATE</div>
                    <div class="stat-value" id="sampleRate">--</div>
                </div>
            </div>
        </div>

        <!-- VISUALIZATION -->
        <div id="vizSection" class="terminal-box hidden">
            <div class="section-title">&gt; REAL-TIME VISUALIZATION</div>
            <div class="controls">
                <button class="btn active" onclick="setMode('spectrogram')">SPECTROGRAM</button>
                <button class="btn" onclick="setMode('waveform')">WAVEFORM</button>
                <button class="btn" onclick="setMode('frequency')">FREQUENCY</button>
            </div>
            <canvas id="canvas" width="1200" height="500"></canvas>
            <div class="stats">
                <div class="stat-box">
                    <div class="stat-label">PEAK FREQ</div>
                    <div class="stat-value" id="peakFreq" style="font-size: 14px;">--</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">AMPLITUDE</div>
                    <div class="stat-value" id="amplitude" style="font-size: 14px;">--</div>
                </div>
            </div>
        </div>

        <!-- TOOLS -->
        <div id="toolsSection" class="terminal-box hidden">
            <div class="section-title">&gt; ANALYSIS TOOLS</div>
            <div class="controls">
                <button class="btn" onclick="reverseAudio()">REVERSE</button>
                <button class="btn" onclick="detectLSB()">LSB CHECK</button>
                <button class="btn" onclick="analyzeNoise()">NOISE FLOOR</button>
                <button class="btn" onclick="showMetadata()">METADATA</button>
                <button class="btn" onclick="downloadViz()">SAVE IMAGE</button>
            </div>
            <div id="toolsLog" class="log"></div>
        </div>

        <div style="text-align: center; margin-top: 40px; color: var(--crt-amber); font-size: 14px;">
            [ G*BOY | MIT License | github.com/eNudimmud/gboy-audio-analyzer ]
        </div>
    </div>

    <script>
        // GLOBALS
        let audioContext;
        let analyser;
        let mediaElement;
        let source;
        let audioBuffer;
        let isVideo = false;
        let vizMode = 'spectrogram';
        let animationId;
        let audioFile;

        // INIT
        window.addEventListener('load', () => {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            setupFileInput();
        });

        // FILE INPUT SETUP
        function setupFileInput() {
            const dropZone = document.getElementById('dropZone');
            const fileInput = document.getElementById('fileInput');

            fileInput.addEventListener('change', (e) => {
                if (e.target.files[0]) loadFile(e.target.files[0]);
            });

            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.style.background = 'rgba(255, 176, 0, 0.2)';
            });

            dropZone.addEventListener('dragleave', () => {
                dropZone.style.background = 'rgba(0, 255, 0, 0.05)';
            });

            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.style.background = 'rgba(0, 255, 0, 0.05)';
                if (e.dataTransfer.files[0]) loadFile(e.dataTransfer.files[0]);
            });
        }

        // LOAD FILE
        async function loadFile(file) {
            audioFile = file;
            isVideo = file.type.startsWith('video');

            log('fileLog', `Loading: ${file.name}`, 'success');
            log('fileLog', `Size: ${(file.size / 1024 / 1024).toFixed(2)} MB`, 'success');

            document.getElementById('fileLog').classList.remove('hidden');

            try {
                // Setup media element
                if (isVideo) {
                    mediaElement = document.getElementById('videoElement');
                    document.getElementById('audioElement').classList.add('hidden');
                    mediaElement.classList.remove('hidden');
                } else {
                    mediaElement = document.getElementById('audioElement');
                    document.getElementById('videoElement').classList.add('hidden');
                    mediaElement.classList.remove('hidden');
                }

                // Load file into media element
                mediaElement.src = URL.createObjectURL(file);
                
                // Wait for metadata
                await new Promise((resolve) => {
                    mediaElement.onloadedmetadata = resolve;
                });

                // Decode audio buffer for analysis
                const arrayBuffer = await file.arrayBuffer();
                try {
                    audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    log('fileLog', 'Audio decoded successfully', 'success');
                } catch (e) {
                    log('fileLog', 'Using media element for analysis', 'warning');
                }

                // Setup Web Audio
                setupAudio();

                // Show sections
                document.getElementById('playerSection').classList.remove('hidden');
                document.getElementById('vizSection').classList.remove('hidden');
                document.getElementById('toolsSection').classList.remove('hidden');

                // Update stats
                document.getElementById('duration').textContent = mediaElement.duration.toFixed(1) + 's';
                document.getElementById('sampleRate').textContent = audioContext.sampleRate + 'Hz';

                log('fileLog', '✅ READY! Press play on the media player', 'success');

            } catch (error) {
                log('fileLog', `Error: ${error.message}`, 'error');
            }
        }

        // SETUP AUDIO ANALYSIS
        function setupAudio() {
            // Remove old source if exists
            if (source) {
                try { source.disconnect(); } catch(e) {}
            }

            // Create analyser
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048;
            analyser.smoothingTimeConstant = 0.8;

            // Connect media element to analyser
            source = audioContext.createMediaElementSource(mediaElement);
            source.connect(analyser);
            analyser.connect(audioContext.destination);

            // Start visualization when playing
            mediaElement.onplay = () => {
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                startVisualization();
            };

            mediaElement.onpause = () => {
                stopVisualization();
            };

            mediaElement.onended = () => {
                stopVisualization();
            };
        }

        // VISUALIZATION
        function setMode(mode) {
            vizMode = mode;
            document.querySelectorAll('.controls .btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
        }

        function startVisualization() {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            function draw() {
                if (mediaElement.paused) return;

                animationId = requestAnimationFrame(draw);

                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);

                if (vizMode === 'spectrogram') {
                    analyser.getByteFrequencyData(dataArray);
                    
                    // Scroll left
                    const imageData = ctx.getImageData(1, 0, width - 1, height);
                    ctx.putImageData(imageData, 0, 0);

                    // Draw new column
                    for (let i = 0; i < height; i++) {
                        const index = Math.floor((i / height) * bufferLength);
                        const value = dataArray[index];
                        ctx.fillStyle = `rgb(0, ${value}, 0)`;
                        ctx.fillRect(width - 1, height - i - 1, 1, 1);
                    }

                    updateStats(dataArray);

                } else if (vizMode === 'waveform') {
                    analyser.getByteTimeDomainData(dataArray);
                    
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, width, height);
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();

                    const sliceWidth = width / bufferLength;
                    let x = 0;

                    for (let i = 0; i < bufferLength; i++) {
                        const v = dataArray[i] / 128.0;
                        const y = v * height / 2;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                        x += sliceWidth;
                    }

                    ctx.stroke();

                } else if (vizMode === 'frequency') {
                    analyser.getByteFrequencyData(dataArray);
                    
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, width, height);

                    const barWidth = width / bufferLength * 2;
                    let x = 0;

                    for (let i = 0; i < bufferLength; i++) {
                        const barHeight = (dataArray[i] / 255) * height;
                        ctx.fillStyle = `rgb(0, ${dataArray[i]}, 0)`;
                        ctx.fillRect(x, height - barHeight, barWidth, barHeight);
                        x += barWidth + 1;
                    }

                    updateStats(dataArray);
                }
            }

            draw();
        }

        function stopVisualization() {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
        }

        function updateStats(dataArray) {
            const maxVal = Math.max(...dataArray);
            const maxIndex = dataArray.indexOf(maxVal);
            const peakFreq = (maxIndex / dataArray.length) * (audioContext.sampleRate / 2);
            
            document.getElementById('peakFreq').textContent = Math.round(peakFreq) + ' Hz';
            document.getElementById('amplitude').textContent = Math.round(maxVal);
        }

        // TOOLS
        function reverseAudio() {
            if (!audioBuffer) {
                toolLog('No audio buffer available', 'error');
                return;
            }

            toolLog('Reversing audio...', 'success');

            const reversed = audioContext.createBuffer(
                audioBuffer.numberOfChannels,
                audioBuffer.length,
                audioBuffer.sampleRate
            );

            for (let ch = 0; ch < audioBuffer.numberOfChannels; ch++) {
                const original = audioBuffer.getChannelData(ch);
                const reversedData = reversed.getChannelData(ch);
                for (let i = 0; i < original.length; i++) {
                    reversedData[i] = original[original.length - 1 - i];
                }
            }

            audioBuffer = reversed;
            
            // Create new audio element with reversed buffer
            const offlineCtx = new OfflineAudioContext(
                reversed.numberOfChannels,
                reversed.length,
                reversed.sampleRate
            );
            const bufferSource = offlineCtx.createBufferSource();
            bufferSource.buffer = reversed;
            bufferSource.connect(offlineCtx.destination);
            bufferSource.start();

            offlineCtx.startRendering().then(renderedBuffer => {
                const wav = bufferToWave(renderedBuffer);
                const blob = new Blob([wav], { type: 'audio/wav' });
                const url = URL.createObjectURL(blob);
                
                mediaElement.src = url;
                setupAudio();
                
                toolLog('✅ Audio reversed! Play to hear it', 'success');
            });
        }

        function detectLSB() {
            if (!audioBuffer) {
                toolLog('No audio buffer available', 'error');
                return;
            }

            toolLog('Analyzing LSB...', 'success');

            const data = audioBuffer.getChannelData(0);
            let ones = 0;
            const samples = Math.min(10000, data.length);

            for (let i = 0; i < samples; i++) {
                const intSample = Math.floor(data[i] * 32768);
                if ((intSample & 1) === 1) ones++;
            }

            const ratio = ones / samples;
            toolLog(`LSB ratio: ${(ratio * 100).toFixed(2)}%`, 'success');

            if (Math.abs(ratio - 0.5) > 0.1) {
                toolLog('⚠ UNUSUAL PATTERN! Possible hidden data', 'warning');
            } else {
                toolLog('Pattern appears normal', 'success');
            }
        }

        function analyzeNoise() {
            if (!audioBuffer) {
                toolLog('No audio buffer available', 'error');
                return;
            }

            toolLog('Analyzing noise floor...', 'success');

            const data = audioBuffer.getChannelData(0);
            const windowSize = 4096;
            let minRMS = Infinity;
            let maxRMS = 0;

            for (let i = 0; i < data.length - windowSize; i += windowSize) {
                const window = data.slice(i, i + windowSize);
                const rms = Math.sqrt(window.reduce((sum, val) => sum + val * val, 0) / windowSize);
                if (rms < minRMS) minRMS = rms;
                if (rms > maxRMS) maxRMS = rms;
            }

            const dB = 20 * Math.log10(maxRMS / minRMS);
            toolLog(`Dynamic range: ${dB.toFixed(2)} dB`, 'success');
            toolLog(`Noise floor: ${(minRMS * 100).toFixed(6)}`, 'success');

            if (minRMS > 0.001) {
                toolLog('⚠ Elevated noise floor detected', 'warning');
            }
        }

        function showMetadata() {
            if (!audioFile) return;

            toolLog('=== METADATA ===', 'success');
            toolLog(`File: ${audioFile.name}`, 'success');
            toolLog(`Size: ${(audioFile.size / 1024 / 1024).toFixed(2)} MB`, 'success');
            toolLog(`Type: ${audioFile.type}`, 'success');
            toolLog(`Modified: ${new Date(audioFile.lastModified).toLocaleString()}`, 'success');
            
            if (audioBuffer) {
                toolLog(`Duration: ${audioBuffer.duration.toFixed(2)}s`, 'success');
                toolLog(`Sample rate: ${audioBuffer.sampleRate} Hz`, 'success');
                toolLog(`Channels: ${audioBuffer.numberOfChannels}`, 'success');
            }
        }

        function downloadViz() {
            const canvas = document.getElementById('canvas');
            const link = document.createElement('a');
            link.download = `gboy_${vizMode}_${Date.now()}.png`;
            link.href = canvas.toDataURL();
            link.click();
            toolLog('Image saved!', 'success');
        }

        // UTILITIES
        function log(elementId, message, type = '') {
            const el = document.getElementById(elementId);
            const div = document.createElement('div');
            div.className = type;
            div.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            el.appendChild(div);
            el.scrollTop = el.scrollHeight;
        }

        function toolLog(message, type = '') {
            log('toolsLog', message, type);
        }

        function bufferToWave(buffer) {
            const length = buffer.length * buffer.numberOfChannels * 2 + 44;
            const arrayBuffer = new ArrayBuffer(length);
            const view = new DataView(arrayBuffer);
            const channels = [];
            let pos = 0;

            // WAV header
            const setUint16 = (data) => { view.setUint16(pos, data, true); pos += 2; };
            const setUint32 = (data) => { view.setUint32(pos, data, true); pos += 4; };

            setUint32(0x46464952); // "RIFF"
            setUint32(length - 8);
            setUint32(0x45564157); // "WAVE"
            setUint32(0x20746d66); // "fmt "
            setUint32(16);
            setUint16(1);
            setUint16(buffer.numberOfChannels);
            setUint32(buffer.sampleRate);
            setUint32(buffer.sampleRate * 2 * buffer.numberOfChannels);
            setUint16(buffer.numberOfChannels * 2);
            setUint16(16);
            setUint32(0x61746164); // "data"
            setUint32(length - pos - 4);

            for (let i = 0; i < buffer.numberOfChannels; i++) {
                channels.push(buffer.getChannelData(i));
            }

            let offset = 0;
            while (pos < length) {
                for (let i = 0; i < buffer.numberOfChannels; i++) {
                    let sample = Math.max(-1, Math.min(1, channels[i][offset]));
                    sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                    view.setInt16(pos, sample, true);
                    pos += 2;
                }
                offset++;
            }

            return arrayBuffer;
        }
    </script>
</body>
</html>